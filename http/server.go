package http

import (
	"encoding/json"
	"errors"
	"fmt"
	app "github.com/erikacarvalho/stone-challenge"
	"github.com/erikacarvalho/stone-challenge/store"
	"github.com/gorilla/mux"
	"log"
	"net/http"
	"regexp"
	"strconv"
)

const JsonContentType = "application/json"

var (
	CPFPattern = regexp.MustCompile(`^\d{11}$`)
	NamePattern = regexp.MustCompile(`^\w+`)
)

var (
	ErrInvalidCPF = errors.New("invalid cpf: it must have 11 numbers")
	ErrInvalidName = errors.New("invalid name: it cannot be empty")
)

type CreateAccountRequest struct {
	Name    string `json:"name"`
	CPF     string `json:"cpf"`
	Balance uint64 `json:"balance"`
}

type CreateAccountResponse struct {
	ID uint64 `json:"id"`
}

type CreateTransferRequest struct {
	AccountOriginID      uint64 `json:"account_origin_id"`
	AccountDestinationID uint64 `json:"account_destination_id"`
	Amount               uint64 `json:"amount"`
}

type CreateTransferResponse struct {
	ID uint64 `json:"id"`
}

type GetBalanceResponse struct {
	ID      uint64 `json:"id"`
	Balance uint64 `json:"balance"`
}

type Server struct {
	accountStore  *store.AccountStore
	transferStore *store.TransferStore
	http.Handler
}


// addAccount creates a new account based on a CreateAccountRequest
// and returns its ID.
func (s *Server) addAccount(w http.ResponseWriter, r *http.Request) {
	if r.Body == nil {
		log.Println("request body is empty")
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("invalid request"))
		return
	}

	creationRequest := CreateAccountRequest{}

	err := json.NewDecoder(r.Body).Decode(&creationRequest)
	if err != nil {
		log.Printf("error decoding body to CreateAccountRequest: %v\n", err)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("invalid request"))
		return
	}

	err = checkCPF(creationRequest.CPF)
	if err != nil {
		log.Printf("error validating CreateAccountRequest: %v\n", err)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(err.Error()))
		return
	}

	err = checkName(creationRequest.Name)
	if err != nil {
		log.Printf("error validating CreateAccountRequest: %v\n", err)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(err.Error()))
		return
	}

	newAccID, _ := s.accountStore.CreateAccount(creationRequest.Name, creationRequest.CPF, creationRequest.Balance)
	jsonBytes, err := json.Marshal(CreateAccountResponse{ID: newAccID})
	if err != nil {
		log.Printf("error marshaling new account ID: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Set("content-type", JsonContentType)
	w.WriteHeader(http.StatusCreated)
	w.Write(jsonBytes)
}

// listAccounts returns the list of all accounts.
func (s *Server) listAccounts(w http.ResponseWriter) {
	getList, err := s.accountStore.ListAllAccounts()

	if err == store.ErrNoRecords {
		w.Header().Set("content-type", JsonContentType)
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("[]"))
		return
	}

	err = json.NewEncoder(w).Encode(getList)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Set("content-type", JsonContentType)
}
// transferAmount is responsible for the whole process of transferring
// an amount based on a request for creating transfer generated by method
// POST on /transfers endpoint. It wraps the methods for creating,
// authorizing and performing a transfer.
func (s *Server) transferAmount(w http.ResponseWriter, r *http.Request) {
	if r.Body == nil {
		log.Println("request body is empty")
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("invalid request"))
		return
	}

	creationRequest := CreateTransferRequest{}

	err := json.NewDecoder(r.Body).Decode(&creationRequest)
	if err != nil {
		log.Printf("error decoding body to CreateTransferRequest: %v\n", err)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("invalid request"))
		return
	}

	origAccount, err := s.accountStore.GetAccount(creationRequest.AccountOriginID)
	if err != nil {
		errMsg := fmt.Sprintf("account %d not found. error: %q", creationRequest.AccountOriginID, err)
		log.Println(errMsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errMsg))
		return
	}
	destAccount, err := s.accountStore.GetAccount(creationRequest.AccountDestinationID)
	if err != nil {
		errMsg := fmt.Sprintf("account %d not found. error: %q", creationRequest.AccountDestinationID, err)
		log.Println(errMsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errMsg))
		return
	}

	newTransferID, err := s.addTransfer(&origAccount, &destAccount, creationRequest.Amount)
	if err != nil {
		errMsg := fmt.Sprintf("error transferring from account [%d] to account [%d]: %s", creationRequest.AccountOriginID, creationRequest.AccountDestinationID, err)
		log.Println(errMsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errMsg))
		return
	}
	jsonBytes, err := json.Marshal(CreateTransferResponse{ID: newTransferID})
	if err != nil {
		log.Printf("error marshaling new transfer ID: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Set("content-type", JsonContentType)
	w.WriteHeader(http.StatusCreated)
	w.Write(jsonBytes)
}

// addTransfer takes in the creation transfer request and transforms into
// a transfer. Its looks for authorization and asks for the exchange of the
// amount if it is authorized. It will return the ID for the new transfer (even
// if it has been not authorized) and an error message. If an error occurs
// specifically when trying to create the transfer in the store, it will return
// id 0 along with the error.
func (s *Server) addTransfer(origin, destination *app.Account, amount uint64) (id uint64, err error) {
	transferID, err := s.transferStore.CreateTransfer(origin.ID, destination.ID, amount)
	if err != nil {
		return 0, err
	}

	err = s.transferStore.AuthorizeTransfer(origin, destination, amount, transferID)

	if err != nil {
		return transferID, err
	}

	err = s.exchangeAmount(origin.ID, destination.ID, amount)
	if err != nil {
		s.transferStore.Cancel(transferID)
	}
	s.transferStore.Confirm(transferID)

	return transferID, nil
}

// exchangeAmount is responsible for perfoming the actual exchange of the
// amount between two accounts.
func (s *Server) exchangeAmount(originAcc, destinationAcc, amount uint64) error {
	//retrieving accounts
	origin, err := s.accountStore.GetAccount(originAcc)
	if err != nil {
		return fmt.Errorf("impossible to retrieve origin account: %w", err)
	}
	destination, err := s.accountStore.GetAccount(destinationAcc)
	if err != nil {
		return fmt.Errorf("impossible to retrieve destination account: %w", err)
	}
	//modifying balances
	origin.Balance, destination.Balance = origin.Balance-amount, destination.Balance+amount
	//persisting new data
	s.accountStore.SetAccount(origin)
	s.accountStore.SetAccount(destination)

	return nil
}

// listTransfer returns the list of all transfers.
func (s *Server) listTransfer(w http.ResponseWriter) {
	transfers, err := s.transferStore.ListAllTransfers()

	if err == store.ErrNoTransfers {
		w.Header().Set("content-type", JsonContentType)
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("[]"))
		return
	}

	w.Header().Set("content-type", JsonContentType)
	err = json.NewEncoder(w).Encode(transfers)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

// accountsHandler redirects '/accounts' endpoint requests to their
// proper Handler depending on the HTTP method.
func (s *Server) accountsHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listAccounts(w)
	case http.MethodPost:
		s.addAccount(w, r)
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

// balanceHandler responds with balance to a given account ID.
func (s *Server) balanceHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	varsMap := mux.Vars(r)
	idStr, ok := varsMap["account_id"]
	if !ok {
		log.Println("it was impossible to obtain the ID from the path")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	ID, err := strconv.ParseUint(idStr, 10, 64)
	if err != nil {
		errMsg := fmt.Sprintf("account ID is invalid. ID given: %v", idStr)
		log.Println(errMsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errMsg))
		return
	}

	balance, err := s.accountStore.GetBalance(ID)
	if err == store.ErrAccountNotFound {
		errMsg := fmt.Sprintf("account %v not found", ID)
		log.Println(errMsg)
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(errMsg))
		return
	}
	jsonBytes, err := json.Marshal(GetBalanceResponse{
		ID:      ID,
		Balance: balance,
	})
	if err != nil {
		log.Printf("error marshaling balance: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Header().Set("content-type", JsonContentType)
	w.WriteHeader(http.StatusOK)
	w.Write(jsonBytes)
}

// transfersHandler redirects '/transfers' endpoint requests to their
// proper Handler depending on the HTTP method.
func (s *Server) transfersHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listTransfer(w)
	case http.MethodPost:
		s.transferAmount(w, r)
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

// transferIDHandler returns all fields of a given transfer ID.
func (s *Server) transferIDHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	varsMap := mux.Vars(r)
	idStr, ok := varsMap["transfer_id"]
	if !ok {
		log.Println("it was impossible to obtain the ID from the path")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	ID, err := strconv.ParseUint(idStr, 10, 64)
	if err != nil {
		errMsg := fmt.Sprintf("transfer ID is invalid. ID given: %v", idStr)
		log.Println(errMsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errMsg))
		return
	}

	transfer, err := s.transferStore.GetTransfer(ID)
	if err == store.ErrTransferNotFound {
		errMsg := fmt.Sprintf("transfer %v not found", ID)
		log.Println(errMsg)
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(errMsg))
		return
	}
	jsonBytes, err := json.Marshal(transfer)
	if err != nil {
		log.Printf("error marshaling transfer: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Header().Set("content-type", JsonContentType)
	w.WriteHeader(http.StatusOK)
	w.Write(jsonBytes)
}

// NewServer returns a new server with an account store, a transfer
// store and its routes.
func NewServer(as *store.AccountStore, ts *store.TransferStore) *Server {
	p := &Server{accountStore: as, transferStore: ts}

	router := mux.NewRouter()

	router.HandleFunc("/accounts", p.accountsHandler)
	router.HandleFunc("/accounts/{account_id}/balance", p.balanceHandler)
	router.HandleFunc("/transfers", p.transfersHandler)
	router.HandleFunc("/transfers/{transfer_id}", p.transferIDHandler)

	p.Handler = router

	return p
}

func checkCPF(cpf string) error {
	if !CPFPattern.MatchString(cpf) {
		return ErrInvalidCPF
	}
	return nil
}

func checkName(name string) error {
	if !NamePattern.MatchString(name) {
		return ErrInvalidName
	}
	return nil
}